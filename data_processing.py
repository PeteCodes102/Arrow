# -*- coding: utf-8 -*-
"""ForwardTestingAppBusinessLogic.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DrKSfau10c6gToKe2MlLgE1gZ_SSVEOp
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install pytest mongomock pymongo beanie plotly

"""# Current To Dos:
```
  [X] -- Take TV alert data and separate by strategy name
  [ ] -- For each strategy
       [X] -- make the timestamp the index and convert the timestamp into DateTime so it is filterable
      [X] -- format the data so that it begins with either a buy or a sell and ends with an exit, so that there are no lingering trades
      [X] -- format the data so that only pairs of buy/exits and sell/exits exist



      [X] -- create a column that calculates the P/L of each trade based on last buy or sell and exit
      [X] -- create a running profit column that calculates the running PnL of the data
      [ ] -- chart the profits on a line chart using plotly   
```
"""

import pandas as pd
import numpy as np
from typing import Optional, Dict
from datetime import datetime as dt
import re

from logic.alert_data.helpers import load_data_from_csv
from constants import *
"""# Models / Typing"""

# Typing

import datetime as dt
from typing import Optional, Literal, Dict, List



from pydantic import BaseModel, Field, ConfigDict

class RawAlert(BaseModel):
  contract: str
  trade_type: TradeType
  quantity: int
  price: float
  secret_key: SecretKey
  timestamp: Timestamp

  model_config = ConfigDict(arbitrary_types_allowed=True)

# Constants


# Utils
import json








# ==> Trim Data to show only closed trades
from __future__ import annotations
import pandas as pd
from typing import Iterable

# === Filters === #

from typing import Iterable, Sequence
import pandas as pd
import numpy as np
from datetime import time
import re





# validate start_time and end_time function




# == Business Logic == #

# ==> Calculate Profit
from __future__ import annotations
import pandas as pd
import numpy as np
from typing import Iterable, Optional, Mapping

from __future__ import annotations
import pandas as pd
from typing import Iterable, Sequence



# Constants / Types
AlgoDict = Dict[str, pd.DataFrame]







NY_FILTER_PARAMS = {
  'start_time': '09:30',
  'end_time': '12:00',
  'days': ['mon', 'tue', 'wed', 'thu', 'fri']
}



split_data = tv_csv_to_split_data('tv_alerts.csv')
keys = list(split_data.keys())
dataframes = [df for df in split_data.values()]
named_df_tuples = list(zip(keys, dataframes))
dataframes.sort(key=len, reverse=True)

example_df = dataframes[0]

example_df.head()







# root function
MultiplierDelta = tuple[float, float]

NQ_MD = 4.0, 5.0
ES_MD = 4.0, 12.5
YS_MD = 4.0, 10.0

quick_add_trade_profit = lambda x, y: add_trade_profit(x, multiplier=y[0], delta=y[1])
add_nq_trade_profit = lambda x: quick_add_trade_profit(x, NQ_MD)
add_es_trade_profit = lambda x: quick_add_trade_profit(x, ES_MD)
add_ys_trade_profit = lambda x: quick_add_trade_profit(x, YS_MD)

for name, example_df in named_df_tuples:
  try:
    example_df = clean_filterable_json_df_pipe(example_df)
    profit_df = add_nq_trade_profit(example_df)
    p = profit_df[profit_df[TRADE_TYPE] == EXIT]
    plot_trading_pnl(p.index, p[rPROFIT], name).show()
  except Exception as e:
    print(f"Error processing {name}: {e}")

